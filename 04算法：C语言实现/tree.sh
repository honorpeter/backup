二叉树：
     遍历：
        前序
        中序
        后序
线索二叉数
        将节点中 的空指针 指向前面的节点
        再加入一个ltag 来判断是之心指向孩子还是前序

        使用中序遍历 来让空指针指向 前序和后序
            树 存储方式 是以树的形式存储
            遍历方式： 前序 中序 后序 。。。。

树 深林 和二叉树相互转换：
        深林： 由多个树组成：
    树和二叉树相互转换：
        首先连接 兄弟节点 
        然后    去掉父节点和右子树之间的连线
    深林和二叉树之间的转换：
        首先： 将每个树变为 二叉树
        然后： 将每个树的根节点  相互连接到一起

    树和深林的遍历：
        前序遍历:
        后序遍历：
    树和深林的前序遍历和转化后的二叉树的前序遍历一样
    后序遍历和 中序遍历一样





赫夫曼编码：
        用作数据压缩:

        赫夫曼树：
                赫夫曼  最优二叉树
                从根节点开始    
                    右子树 为 1
                    左子树为  0
    构建赫夫曼编码：
        统计数据中每个字符出现的频率        按照频率大小进行排序
            从最小的开始合成一个节点 频率相加  再取数构建    构建赫夫曼树
            左边的节点小于右边的节点

        使用table：
            使用table将一个字符和011101。。这样的0 1 对应起来
                这里的字符便是 原文的字符   使用0 1序列代替字符 

图：
        存储方式：
            邻接矩阵：
            邻接表：
            十字链表:有向图
                关注的重点是边
                出度 连接起来   入度连续指过去
            邻接多重表： 无向图
                 每个边依附于顶点而存在
            边集数组：
                每个顶点： 边的开始 边的结束 权重
    图的遍历：
        深度优先遍历：
            遍历：是指的是：走过所有的顶点。。。。
                    遍历走过的点 为树
        广度优先遍历：
            使用队列来实现
                将第一个节点放入队列中  出队列将连接他的节点放入。。。

    最小生成树：
        有n-1条边   组成的树 
        图中的每个边都有权值
        找到连通每个图中每个节点的  最短路径( 权值加上)

        怎么查找：
            普利姆算法：对于顶点来实现的 
            克鲁斯算法:对于边实现的 
    最短路径：
        图中两点之间    最短的路径  边上有权值
        迪斯卡算法： 从顶点开始入手
        弗洛伊德算法：


拓扑排序：
    AOV网图没有回路
    拓扑序列：  有优先级

关键路径：
    找到    权值最大的路径
    关键路径是 边的集he













