内存管理： memory management
    cup直接和内存打交道 不会和硬盘打交道
    Primary Memory (内存通常成为 RAM)
        内存 为每一个进程分配 2的46次方 虚拟内存 理论上讲         
                2的32次方 4G
            程序加载到内存   地址重定位方法
                静态重定位
                    加载程序时 将全部地址 改变为实际物理内存地址
                     这样 以后想移动 不好移动
                动态重定位
                    程序地址实际内存中的首地址为存放到基址寄存器中
                        程序中后面的每个地址 都加上基址寄存器
                        这样以后 想改变实际内存的地址时 
                        只需要改变 基址寄存器
                        一般还有一个寄存器 记录终端点的位置 防止访问非法区域
                        程序中所有的jmp必须小于这个值

                程序的地址：
                    编译器编译完之后生成 逻辑地址 或 相对地址
                    程序加载到内存中的地址是 实际地址


内存管理:
    分区管理：
        固定分区：先给内存分好区 每个分区中只能放一个进程  分区大小不能改变
            算法： 进程使用时 挑选 合适最小的内存
        不固定分区：
            随着进程 产生 消亡 会产生 外部碎片
            内存挤缩技术(将程序内存放在一起) 不现实 耗时间

    当内存不够的时候 使用硬盘 虚拟内存
        局部原理：程序一般 主要执行一部分代码
    Swapping:
        当内存空间不够的时候  又有新的进程来的时候  
            挑选 睡着的进程（一时 半会不会醒的进程）放进Swapping分区中
                整个搬进搬出
    分页管理； Virtual Memory
        把逻辑地址分固定的大小分成相等的几页
            把实际内存分为大小相等的几页        一般都为4kb
            使用 一个分页表 将逻辑地址和实际内存对应起来（可以不连续）
        请求式分页：
            当某一页的数据不用的时候 将它放在swapping分区中 当它使用时
                再调到内存
            如何实现重定位 每一页
                每一个页都有一个 基址寄存器   重定位的时候 每页中 程序的地址
                    都加上基址寄存器
                    分页表 低十二位 是标记这个也的状态
        分页表：
            类似数组的数据结构  下标 为程序的每个页的页号
                                值为 实际内存中的页帧号（也就是起点的位置）
                                     和一些属性（低十二位）在不在内存中。。
        分页带来的问题：    
            执行程序的时候还要访问 分页表 时间增加
                使用TLB来加速:
                加分页表项 常用的放到Cache中 一般存放16项 命中率97%统计
                    没有命中的话： 去内存中找
                    内存中没有的话 产生缺页中断 到硬盘上寻找

                缺页中断的执行过程：    换入换出  一个进一个出
                    当发生中断的时候 先保存现场
                        先看出去的那一个：
                            如果是脏的 被修改过了 写入硬盘
                            如果是干净的    直接扔掉
                        从硬盘上 读取这个页 
                        更新页表 更新状态。。
                        恢复现场    执行刚才正在执行的语句 
                            一般中断 都是执行 下一条语句 这个不是
                            因为没有数据 所以执行不完
            分级页表：
                因为页表 很大 所以将他们 分开
                    将页表项分为多个 小的页表项 使用一个页表项目录来记录下来
                    这就形成了 级  目录 为二级      页表项为 一级 
                    这种方式 一般到三级 都停止了
            倒插分页：
                将数据表的下标和值换一下位置
                这样 就可以 只有一张 表 了(一个值无序 很多值 的数组)  
                    但这样要 通过 值来求下标 来寻找 物理地址
                        使用哈希表 分堆 以奇偶来分 再以最后的数大小以为来分
                            这样寻找的时候 就可以很快的找到了
                    

                对于linux  将内存的东西 放到Swap分区中
                对于windows     将它放在 c盘下 pagefiles的一个文件里
                      一般是内存的2倍大
            分页管理的弊端：
                因为是操作系统 固定划分的所以会出现
                    一个页面有读的也有写的 代码段和数据段 这样不好保护
                还会出现 一个循环被分在两个页上 那么执行这个循环的过程宏
                    大部分时间都是 换页     所以出现了 分段管理

        分段管理：
            有一个段表
            将程序代码 分为几个段  代码段1 代码段2 。。。数据段 heap stack
            进行调用换入换出
                引入新的问题： 和分区式管理差不多 碎片 怎么放
        段页式管理：
            太麻烦了  先查段表 在查也表
            先按照逻辑分为几个段 
            再在段中分为几个页  以段为整体 换入换出

    页面置换算法：
        何时淘汰：
            一般内存空间剩余 一个下线的时候 开始淘汰  因为这样可以
                错开 缺页中断和淘汰
        淘汰谁：
            1 淘汰 最近不用的  保留刚刚用过的
                    页表项 底十二位有记录： P 为 1表示用过
                                            R  为1表示最近用过
                                            M 为1表示修改过
                                    淘汰：p为1的
                                        优先淘汰： R为0的
                                            在优先： M为0的 
                                                M为1的还有下如 Swap区
            2 LRU 最近用的很少的淘汰    
                 最近是指的是时间       用的很少是频率  同时考虑
                 几乎不可能实现

            3 先进先淘汰  不行
        
    Secondary Memory (硬 盘)

为了向下兼容： 8086cpu  有实时模式
    当cup开启的时候 首先进入 实时模式
        实时模式也就是 20位寻址的cpu
                A20问题：   FFFF0 + FFFF 加完之后会 溢出
                            一溢出 A20便会等于 1 
                            在 实时模式下没有作用  不管A20 他会从头开始寻址
                            在保护模式下 应该打开A20 它便可以先下访问地址









硬盘：一般两大类
        有机械臂 磁头 的
        没有上面的两个的另一类  flash  u盘



Memory Hierarchy
        Register 
        Cache
        memory
        disk
        磁带


