概论：
        一旦内核启动，它以网格的形式运行，其中该网格包含多个线程块 
            每个线程块又由多个线程构成.但并非线程块都是并发运行的，每个
            线程块都分配给一个SM，而每个SM都可以为多个线程块维持上下文
            为了掩盖内存和指令带来的延时，SM通常需要多于单线程快可以包含
            的线程束（SM2.0及以上，一个线程块最多可以包含1024线程）
            每个SM中线程块的最大数目无法通过API查询，文档中写明，SM3.x版本
            之前的硬件中是8     SM3.x之后的是16

语法：
        内核启动：
            Kernel <<<gridSize,blockSize,sharedMem,Stream>>>(param)
                gridSzie,blockSzie      dim3结构形式
                sharedMem:指定为每个线程块预留的附加的共享内存
                Stream:指定内核启动属于的留

                dim3结构：
                    c++会默认初始化为1
                    struct __device_builtin_ dim3
                    {
                        unsigned int x,y,x;
                        #if defined(__cplusplus__)
                        __host__ __device__ dim(
                            unsigned int vx = 1,
                            unsigned int vy = 1,
                            unsigned int vz = 1
                            ):x(vx),y(vy),z(vz){}
                            __host__ __device__ dim3(uint3 v):x(v.x),y(v.y)
                                ,z(v.z){}
                            __host__ __device__ operator uint3(void){
                                uint3 t;
                                t.x = x;
                                t.y = y;
                                t.z = z;
                                return t;
                            }
                            #endif
                    }
            内核程序可以通过驱动程序API使用cuLanchKernel()来启动
        局限性：   
            所有参与内核启动的C++类都必须是带有以下特性的 简单旧数据
                无用户生命的构造函数
                无用户定义的复制分配操作符
                无用户定义的析构函数
                无非POD的非静态数据成员
                无私有或保护型的非静态数据
                无基类
                无虚函数
            注意：违背了这些规则的类也可以用于CUDA，甚至是内核程序中，但是
                却对不能用于内核启动中
        高速缓存和一致性：
            常量缓存被充分利用起来以便于广播式传输到同一个SM的执行单元
            纹理缓冲则减少了外部带宽的使用

        异步与错误处理：
            内核启动是异步的  这回是错误处理变得非常复杂

            无效内核启动：  
                运行时：应用程序可以通过cudaGetLastError()函数来查询该错误值
        超时：
                GPU在CUDA内核执行期间不能进行上下文切换，所以长时间运行CUDA
                    内核可能会对使用GPU来与用户的系统的交互性产生负面影响
                    因此 如果GPU运行太久没有进行上下文切换，去躲CUDA系统讲
                    实施超时以重置

        本地内存：
            本地内存是线程私有的，且CUDA中的网格可以包含数千个线程，所以
                CUDA需要的本地内存数目是相当多的

线程块，线程，线程束，束内线程：
        内核以线程块构成的网格进行启动，这些线程可以进一步分为32个线程组成
            的线程束，每个线程束被成为一个束内线程

        线程块网格：
            线程块独立被调度SM中，来自于同一线程的线程在同一SM中执行
                网格可以由高达65535*65535个线程块（对于SM1.0的硬件）或
                65535*65536*65535的线程块组成。 每个线程块可以由高达512或
                1024个线程组成. 而线程块中的线程之间可以通过SM的共享内存进行
                通信。

        线程：
            每个线程都可以得到属于自己的一组完整的寄存器和一个线程块中唯一的
                线程ID。
                引用寄存器的内置变量：
                    gridDim     网格的维数
                    blockDim    线程块的维数
                    blockIdx    线程快索引
                    threadIdx   线程索引
                    
                一个线程的“全局”索引可以如下计算：在线程块内的索引
                    int globalThreadId = 
                        threadIdx.x + blockDim.x * (threadIdx.y+blockDim.y* 
                            threadIdx.z);

        对象作用域：
            寄存器          线程    
            共享内存        线程块
            本地内存        线程束
            常量内存        网格
            全局内存        网格
            纹理引用        网格
            流              线程块
            事件            线程块

        执行保证：
            在一个给定线程块中的线程保证驻留于同一SM，所以他们可以通过
                共享内存交换信息以及使用__syncblocks()函数同步
                但线程块没有任何类似可以进行数据交换或同步机制

        线程块和线程ID：
            线程与线程块ID会在一个CUDA内核开始执行时分配，对于2D，3D网格和
                线程块，他们会以行优先顺序进行分配
                线程快大小最好是32的倍数，

                     
动态并行：
        动态并行是仅用于SM3.5架构硬件的新功能，可以使CUDA内核启动其他CUDA
            内核，同时也可以在CUDA运行时调用各种函数。当使用动态并行时，
            CUDA运行时的一个子集可以为设备上运行的线程使用。
        动态并行引入 父 和 子 网格的术语。任何被另外一个CUDA内核启动的内核
            成为子内核。 默认情况下CUDA支持两级嵌套。这个数目可以通过，调用
            带cudaLimitDevRuntimeSyncDepth标志的cudaSetDeviceLimit()函数
            增加
        注意：动态并行只在一个给定GPU中有效。
    作用域和同步：
        子网格会继承其父网格的线程块和网格大小之外的绝大部分内核配置参数，
            如共享内存配置。线程块是基本单元，一个线程快创建的流和事件仅能
            被该线程块使用
            在主机上创建的流和事件 不能通过动态并行在设备上使用

            CUDA确保在所有子网格完成之前，父网格是不会王超的，如果线程块中
                的所有线程都退出，该线程块的执行将会挂起，直到所有子网格
                完成为止。
            cudaDeviceSynchronzie()函数对由快中任何线程启动的挂起工作进行
                同步，然而，他不执行任何线程间的同步。

        内存模型：
            全局内存 和 常量内存都是看见的 对于 父子网格

        共享内存和本地内存：
            对于线程块和线程分别是私有的，父子网格之间不可见。

        流与事件：
            设备运行时所创建的流和事件，仅能在创建的他们的线程快中使用。
            。。。。


错误处理：
        如果一个子网格发生错误，CUDA会返回一个错误给主机，而不是父网格

编译和链接：
    必须对设备运行时的静态库进行显示链接，在windows中，设备运行时为
        cudadevrt.lib   在linux  -lcudadevrt

        










