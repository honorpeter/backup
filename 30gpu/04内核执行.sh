概论：
        一旦内核启动，它以网格的形式运行，其中该网格包含多个线程块 
            每个线程块又由多个线程构成.但并非线程块都是并发运行的，每个
            线程块都分配给一个SM，而每个SM都可以为多个线程块维持上下文
            为了掩盖内存和指令带来的延时，SM通常需要多于单线程快可以包含
            的线程束（SM2.0及以上，一个线程块最多可以包含1024线程）
            每个SM中线程块的最大数目无法通过API查询，文档中写明，SM3.x版本
            之前的硬件中是8     SM3.x之后的是16

语法：
        内核启动：
            Kernel <<<gridSize,blockSize,sharedMem,Stream>>>(param)
                gridSzie,blockSzie      dim3结构形式
                sharedMem:指定为每个线程块预留的附加的共享内存
                Stream:指定内核启动属于的留

                dim3结构：
                    c++会默认初始化为1
                    struct __device_builtin_ dim3
                    {
                        unsigned int x,y,x;
                        #if defined(__cplusplus__)
                        __host__ __device__ dim(
                            unsigned int vx = 1,
                            unsigned int vy = 1,
                            unsigned int vz = 1
                            ):x(vx),y(vy),z(vz){}
                            __host__ __device__ dim3(uint3 v):x(v.x),y(v.y)
                                ,z(v.z){}
                            __host__ __device__ operator uint3(void){
                                uint3 t;
                                t.x = x;
                                t.y = y;
                                t.z = z;
                                return t;
                            }
                            #endif
                    }
            内核程序可以通过驱动程序API使用cuLanchKernel()来启动
        局限性：   
            所有参与内核启动的C++类都必须是带有以下特性的 简单旧数据
                无用户生命的构造函数
                无用户定义的复制分配操作符
                无用户定义的析构函数
                无非POD的非静态数据成员
                无私有或保护型的非静态数据
                无基类
                无虚函数
            注意：违背了这些规则的类也可以用于CUDA，甚至是内核程序中，但是
                却对不能用于内核启动中
        高速缓存和一致性：
            常量缓存被充分利用起来以便于广播式传输到同一个SM的执行单元
            纹理缓冲则减少了外部带宽的使用

        异步与错误处理：
            内核启动是异步的  这回是错误处理变得非常复杂

            无效内核启动：  
                运行时：应用程序可以通过cudaGetLastError()函数来查询该错误值
        超时：
                GPU在CUDA内核执行期间不能进行上下文切换，所以长时间运行CUDA
                    内核可能会对使用GPU来与用户的系统的交互性产生负面影响
                    因此 如果GPU运行太久没有进行上下文切换，去躲CUDA系统讲
                    实施超时以重置

        本地内存：
            本地内存是线程私有的，且CUDA中的网格可以包含数千个线程，所以
                CUDA需要的本地内存数目是相当多的

线程块，线程，线程束，束内线程：
        内核以线程块构成的网格进行启动，这些线程可以进一步分为32个线程组成
            的线程束，每个线程束被成为一个束内线程

        线程块网格：
            线程块独立被调度SM中，来自于同一线程的线程在同一SM中执行
                网格可以由高达65535*65535个线程块（对于SM1.0的硬件）或
                65535*65536*65535的线程块组成。 每个线程块可以由高达512或
                1024个线程组成. 而线程块中的线程之间可以通过SM的共享内存进行
                通信。

        线程：
            每个线程都可以得到属于自己的一组完整的寄存器和一个线程块中唯一的
                线程ID。
                引用寄存器的内置变量：
                    gridDim     网格的维数
                    blockDim    线程块的维数
                    blockIdx    线程快索引
                    threadIdx   线程索引
                    
                一个线程的“全局”索引可以如下计算：在线程块内的索引
                    int globalThreadId = 
                        threadIdx.x + blockDim.x * (threadIdx.y+blockDim.y* 
                            threadIdx.z);

        对象作用域：
            寄存器          线程    
            共享内存        线程块
            本地内存        线程束
            常量内存        网格
            全局内存        网格
            纹理引用        网格
            流              线程块
            事件            线程块

        执行保证：
            在一个给定线程块中的线程保证驻留于同一SM，所以他们可以通过
                共享内存交换信息以及使用__syncblocks()函数同步
                但线程块没有任何类似可以进行数据交换或同步机制

        线程块和线程ID：
            线程与线程块ID会在一个CUDA内核开始执行时分配，对于2D，3D网格和
                线程块，他们会以行优先顺序进行分配











