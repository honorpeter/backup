动态行为：
        无法知道 具体在那个状态     事件驱动行为
        状态： 生命 周期某个阶段。。。

状态图：
        被动对象： 必须由其他对象发送消息 才能唤醒它
        主动对象： 自身封装了一个线程 
    什么时候使用：
            当动作的执行过程 具有随机性的时候 没有实现确定好顺序 那么就使用
            状态图。。。。。  事件驱动模型
        

    基本状态图：
            状态: 在某些状态下执行的某些行为的集合
                    将事件和动作 建立了映射
            事件(触发器):交互事件  时刻时间  对象数据的变化
            动作 :  原子性
                    设置对象属性的时候
                    发送消息
                    执行对象的一个操作
                    ......
            活动：不满足原子性  可以认为 连续的动作集合
            转换 内部转换
            延迟事件： 事件列表  当时的状态还不具备 执行事件的条件 等具备了
                        再执行
            伪状态：
                    不是状态 像状态 代词 简化效果  没有内部转换 不持续时间
                    选择伪状态  析构伪状态  
            最终状态：
                    内部没有转换    可以持续一段时间

    建立状态图的过程：  和原来的状态有关 时序电路
            1. 识别事件
                    外部事件 内部事件
            2  在事件的启发下 识别状态
            3  组合事件和状态  最后 事件和状态 形成一个封闭区间
            4  形成状态转换表

    将状态图转化为代码：
            1 可以使用 自动转化
            2   实现由对象执行的动作
                为了捕获状态 引入枚举数据类型
                给类添加状态变量
                引入助手函数 以管理状态的进入和退出
                        主函数 switch。。。。。
                实现事件处理程序    
                
复杂的状态：
        组合状态：
                大的状态中会 嵌套小的状态  可能存在二义性  规定明确啊
        历史状态：
                返回到以前访问的等级状态
                深历史状态:
                        继承实现
                浅历史状态：
                        继承实现
        并发状态：
                对相同实体的多种同时的视角      不同的视角 可以正交
                正交区之间的交互

            


                                                        




