抽象数据主要思想：
        主要 是数据
        提供的各种函数的接口都是操作 的数据
        数据一般是内存分配的地方    需要有一个指针关联到哪里
        这样可以    把这些接口函数比作 工厂那么多个数据 可以同时加工
模块分为两个部分：
        模块的接口与实现：
            接口：
                声明标识符  类型 和 例程    提供给使用模块的代码
            实现：
                致命模块如何完成接口规定的目标

            设计完善且陈述准确的接口可以减少耦合

抽象数据类型：
        一个抽象数据类型是一个接口  它定义了一个数据类型和对该
            数据类型的值所进行的操作

        一个数据类型是一个值的集合

    抽象数据类型： 栈
        typedef struct Stack_T *Stack_T;    
            指向同名结构:   该定义是合法的：
                            因为结构 联合和枚举的名称 占用了一个命名空间
                           不同与变量 函数和 类型名所用的命名空间

            这里使用了 typedef定义了指针 这样Stact_T 不能声明指针
                可以对外提供接口
            使用相同的名称 可以避免用太多的罕见的名称污染代码

        #ifndef STACK_INCLUDE
        #define STACK_INCLUDE
        #endif
        使用这个     可以避免重复包含   这个头文件 不至于这个文件中
                        typedef 重复定义 出错
        STACK_INCLUDE 命名：
                使用_INCLUDE避免命令重复
                也可以使用前缀
                    _STACK  OR  _STACK_INCLUDED
                标准c将下划线 前缀 留给实现者和未来扩展使用
                所以 应当避免使用前缀

        Stack接口规定了三个已检查的运行错误：
                1 向该接口中的任何 例程传递空的Stack_T类型的指针
                2 传递给 Stack_free的Stack_T指针为NULL指针
                3 传递给Stack_pop的栈为空
            使用assert()函数

        异常：
                Stack_new Stack_push可能引发Mem_Failed 异常
        未检查的运行错误：
            elem里面的void指针 
                void *指针变量可以容纳指向一个对象的任意指针
                    可以是预定义类型 结构 和 指针 但函数指针不同
                    有的可以指向函数指针有的不行 所以这是一个未检查的运行。
            void指针 不会修改 原来的类型
                S *p, *q;
                void *t;
                t = q;
                p = t;
                那么 p = q
                但 p是D指针的话
                就不行了。。
                这也是一个未检查的类型错误
        详见：  function/stack/....
    接口通常会规定 
            未检查的运行错误 已检查的运行错误    
                        ：是用户非预期的用户错误 是无法恢复的程序bug
            和 异常
                        :是指一些可能的情形 但很少发生

        


         


















