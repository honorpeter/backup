原因:   
        不同的进程有不同的调度需求
        io密集型 cpu密集型

进程的分类:
        实时进程:
        交互式进程:
                shell进程

进程调度:
        调度的时机 :
            中断处理(包括时钟中断 IO中断 系统调用异常)
        内核线程可以直接调用schedule 进行进程切换 也可以在中断处理中被动调用

进程切换:
        挂起进程在cpu上的执行 和 中断处理保存现场是不同的 
            后者是在同一个进程内 只是陷入内核态而已
            前者已经改变进程了



“有两种生成一个软件设计方案的途 径:一个是把它做得如此简单,以致
于明显不会有漏洞存在。另一个是把 它做的如此复杂,以致于不会有明显
的漏洞存在。”——Tony Hoare






















